\documentclass[12pt, letterpaper]{article}
\usepackage{graphicx}
\usepackage[
backend=biber,
style=alphabetic,
sorting=ynt
]{biblatex}
\addbibresource{bibliografie.bib}
\graphicspath{{images/}}
\title{Demonstrații zero-knowledge de apartenență la mulțimi}
\author{Andrei Pârjol}
\date{April 2024}

\begin{document}

\maketitle

\section{Introducere}

\subsection{Obiective} Obiectivul lucrării de față este acela de a prezenta și studia conceptele și implementările curente pentru protocoalele zk-SNARK folosite în demonstrațiile de apartenență la mulțimi. Deși pot părea abstracte la prima vedere , această ramură de demonstrații (in eng. \emph{zero-knowledge proof of membership}) are o gamă largă de aplicații precum : anonimizarea tranzacțiilor cu criptomonede (e.g. protocolul Zcash pentru Bitcoin și protocolul Tornado Cash pentru Ether), votul electronic descentralizat și anonim (e.g. putem să demonstrăm ca avem dreptul să votăm fără să dezvăluim date personale) sau mai general, folosirea anonimă a unor servicii online (e.g. fără să folosim username/password).

\subsection{Contribuția personală}

Pentru a arăta relevanța ideilor prezentate în această lucrare am scris o librărie JavaScript care implementeaza arborii hash Merkle și procedurile de generare și verificare a demonstrațiilor pentru apartenență folosind SNARK-uri. De asemenea se propun și îmbunătățiri , folosind arbori hash "\emph{indexați}" care reduc adancimea arborelui și implicit numărul de apeluri la funcția hash folosită in circuitul algebric.

\pagebreak

\section{Fundamente teoretice}
\subsection{Scurt istoric}
\vspace{5mm}
    Termenul de zero knowledge a fost propus prima dată la mijlocul anilor 1980 de către cercetătorii  Shafi Goldwasser , Silvio Micali și Charles Rackoff de la Institutul de tehnologie din Massachusetts . Ei încercau sa rezolve problemele legate de sistemele de demonstrare interactive , sisteme teoretice în care o parte numită Prover încearcă să convingă o altă parte numită Verifier că o propoziție matematică este adevărată.

    Acest tip de sistem este numit interactiv deoarece cele două părți interschimbă mesaje în timpul procesului de demonstrare și la vremea respectivă o mare parte din muncă era îndreptată înspre asigurarea validității sistemului, adică rezolvarea cazului în care Prover-ul avea intenții malițioase și încearca să păcălească Verifier-ul în a crede o propoziție falsă.

	În sistemele de demonstrare interactive este presupus că Demonstratorul are putere de calcul nelimitată (informal toate problemele sunt fezabile) însă nu este de încredere și Verificatorul are putere de calcul limitată și este onest. Ce au făcut cei trei cercetători a fost să ia în considerare și cazul în care Verificatorul nu este de încredere și s-au întrebat ce informații poate să obțină Verificatorul după o demonstrație. O astfel de scurgere de informații este destul de gravă deoarece din ipoteză folosind aceste sisteme Verificatorul are acces la informații pe care în mod normal nu ar fi putut să le calculeze. 

	A fost fost propusă astfel implementarea unui nou sistem , zero knowledge , în care se demonstrează cunoașterea unei soluții la o problemă în loc de soluție în sine . După terminarea demonstrației Verificatorul nu învață nimic nou în afara faptului că Demonstratorul cunoaște soluția.\cite{greenandblazewebsite}

 \subsection{Zero Knowledge}
 
 Dat fiind un sistem de demonstrație (P,V) și un Limbaj L (astfel încât $x\in L$ să fie echivalent cu x este adevărat ), acest sistem este zero knowledge dacă satisface următoarele trei proprietăți: 


\textbf{Completitudine} : $x\in L$  Pr[V acceptă ] = 1 . x este acceptat cu probabilitate 1 atunci când avem un demonstrator și verificator onest  .


\textbf{Corectitudine} : $x\in L$  Pr[V acceptă ] = 1/n , $n\in N$ . x este acceptat cu probabilitate redusă/mică  atunci când avem o demonstrație mincinosă și un verificator onest.


\textbf{Zero Knowledge} : Pentru orice verificator V exista o simulare S astfel încât orice rezultat final sau intermediar obținut de V se poate obține și de către S. Informal V nu poate să calculeze nimic din ce nu putea să calculeze înainte de verificarea demonstrației.

\subsection{zk SNARKs}
Este un obiect criptografic care poate să genereze într-un mod eficient un protocol zero knowledge pentru orice problemă sau funcție. 

zk SNARKs au următoarele proprietăți:
\begin{itemize}
\item {\textbf{zk} : intrările funcțiilor rămân ascunse} 
\item{\textbf{Succint} : demonstrațiile generate sunt scurte și pot fi verificate rapid.}
\item{\textbf{Noninteractive} : nu este necesară comunicarea prin întrebări și răspunsuri dintre Demonstrator și Verificator.}
\item{\textbf{ARgument of Knowledge} : se demonstrează cunoașterea unei intrări x pentru o funcție și un rezultat dat.}
\end{itemize}
Ideea de bază:
Se transformă problema (ex: logaritm discret , colorarea grafului etc.) într-o funcție a cărei intrări vrem să le ascundem.
Executăm funcția folosind criptarea homeomorfă și funcția este apoi trecută printr-un procedeu numit “roll up” în care se obține o semnătură scurtă care indică execuția corectă a funcției.

\pagebreak
\section{Acumulatori criptografici}
Un acumulator criptografic este o reprezentare compactă a unei mulțimi de elemente sub forma unui hash. 

Această reprezentare permite generarea de demonstrații de apartenență scurte, notate $w_x$ și numite witness(martor),pentru orice element $x$ care a fost acumulat sau demonstrații de non-apartenență pentru orice element din domeniu care nu a fost acumulat.

Acumulatorii care suportă doar demonstrații de apartenență sunt numiți \emph{pozitivi}, cei care suportă doar demonstrații de non-apartenență sunt numiți \emph{negativi} iar cei care suportă ambele tipuri de demonstrații sunt numiți \emph{universali}.

O altă clasificare pentru acumulatori este dată de metodele de actualizare pe care aceștia le suportă, astfel avem acumulatori:
\begin{itemize}
    \item{\textbf{aditivi} - suportă doar introducerea de elemente noi în mulțime}
    \item{\textbf{substractivi} - suportă doar eliminarea de elemente din mulțime}
    \item{\textbf{dinamici} - suportă ambele operații descrise mai sus}
\end{itemize}

Dacă avem o entitate(trusted party) responsabilă pentru actualizarea acumulatorului acesta se numește \emph{trapdoor-based} altfel acesta se numește \emph{trapdoorless}.

Pentru acumulatorii \emph{trapdoor-based}, entitatea responsabilă pentru actualizarea mulțimii suport se numește \emph{managerul acumulatorului}. Acesta deține o cheie secretă (\emph{trapdoor}) și este capabil să adauge , să șteargă elemente și să genereze demonstrații într-un mod eficient.

Acumulatorii \emph{trapdoorless} permit actualizări publice asupra mulțimii suport, fără a mai fi nevoie de o parte terță de încredere. Astfel utilizatorii sunt responsabili pentru actualizarea și generarea de demonstrații.


Acumulatorii criptografici au numeroase aplicații,cele mai populare fiind : anonymous credentials , group signatures, stocarea datelor in cloud și anonimizarea tranzacțiilor cu criptomonede.
\cite{cryptoeprint:2023/1001}

\subsection{Date private și scalabilitate}

Din definiția dată mai sus acumulatorii criptografici nu au nicio propietate care să păstreze datele private. O parte malițiosă poate să afle pentru ce element din mulțime s-a făcut o demonstrație sau poate să afle ce element a fost șters sau adăugat în acumulator. Aceste informații pot fi folosite pentru a falsifica demonstrații și pentru a actualiza abuziv mulțimea/acumulatorul.

În practică acumulatorii sunt folosiți în zone în care datele trebuie să rămână private așa că demonstrațiile convenționale sunt înlocuite cu demonstrațiile \emph{zero-knowledge}. Odată cu schimbarea tipului de demonstrație folosit apar și probleme noi pe care le vom discuta și rezolva în continuare : \emph{replay attacks} - folosirea repetată a aceleiași demonstrații, timpi de lucru mari pentru generarea demonstrațiilor și probleme de concurență atunci cand doi sau mai mulți utilizatori încearcă să actualizeze același acumulator în același timp.

Dorim totodată ca acumulatorul să fie scalabil și să ne permită să verificăm apartenența $x \in S$ într-un timp subliniar, fără să reținem toate elementele din $S$.

Pentru a realiza cele două obiective trebuie să definim părțile care participă în procesul de demonstrare : 
\begin{itemize}
    \item{\textbf{Prover} - cunoaște valoarea secretă $x$ și mulțimea $S$ și are spațiu de memorie și putere de calcul nelimitate. Acesta este responsabil de generarea demonstrației de apartenență.}
    \item{\textbf{Verifier} - nu cunoaște valoarea secretă $x$ sau mulțimea $S$ și deține spațiu de memorie și putere de calcul limitate. Acesta este responsabil de verificarea demonstrației de apartenență.  }
\end{itemize}

Împărțind problema celor două roluri putem să păstrăm datele private și să obținem scalabilitate.

\subsection{Verificarea eficientă a demonstrațiilor}

Formal un acumulator poate fi descris printr-un triplet de 3 algoritmi : $(Acc,Prove,Verify)$ care au următoarele funcționalități:
\begin{itemize}
    \item{\textbf{$A \leftarrow Acc(S)$} - realizează compresia mulțimii $S$ într-o valoare scurtă notată cu A.}
    \item{\textbf{ $\pi_x \leftarrow Prove(x,S)$} - generează demonstrația de apartenență la mulțimea $S$ pentru elementul $x$.}
    \item{\textbf{ $\{0,1\} \leftarrow Verify(A,x,\pi_x)$} - acceptă sau respinge demonstrația $\pi_x$ folosind doar valoarea comprimată $A$.}
\end{itemize}

Pentru a fi considerate eficiente, dimensiunea acumulatorului $A$ , a demon-
strației $\pi_x$ și complexitatea timp a algoritmului $Verify$ trebuie să fie mai mici decât $|S|$. În continuare sunt prezentați arborii hash Merkle în care algoritmul $Verify$ are o complexitate timp $O(log(|S|))$. 

\subsection{Arbori hash Merkle - $Acc(S)$}
Arborii hash Merkle sunt arbori binari în care valoarea fiecărui nod este dată de o funcție hash criptografică care primește ca și intrări valorile copiilor nodului, sau dacă nodul este nod frunză primește cheile secrete din mulțimea suport. 

Funcția hash folosită intr-un arbore Merkle este importantă deoarece în contextul zero-knowledge dorim o funcție care sa fie ușor de scris sub-forma unui circuit algebric pentru a genera un SNARK cât mai eficient și cu cât mai puține constrângeri. Astfel de funcții hash sunt numite și \emph{"zk-friendly"}, iar câteva funcții folosite în practică sunt  : Poseidon \cite{cryptoeprint:2019/458} , MiMC \cite{cryptoeprint:2016/492} , Vision Mark-32 \cite{cryptoeprint:2024/633} sau Rescue \cite{cryptoeprint:2022/1577}. În implementarea prezentată în această lucrare vom folosi funcția hash Poseidon , prescurtată cu POS.

În Figura \ref{fig:arbore_hash1} de mai jos este prezentat un arbore hash de adâncime 3 în care am acumulat cheile secrete $S=\{A,B, \dots ,F\}$. Nodurile frunză conțin doar hash-urile $\{POS(A),POS(B), \dots ,POS(F)\}$, iar nodurile care nu au o valoare setată primesc o valoare \emph{null} notată cu \emph{zeroVal} sau \emph{0}. 

Folosirea unei valori \emph{null} prestabilită ne permite să implementăm într-un mod eficient arbori Merkle \emph{sparse} care au o adancime foarte mare însă puține elemente deoarece putem să calculăm valorile null pentru fiecare nivel de adâncime.

Arborii Merkle au o proprietate adițională care îi face mai puternici decât alți acumulatori criptografici deoarece realizează un \emph{"vector commitment"} : rădăcina arborelui codifică nu numai conținutul mulțimii dar și ordinea în care elementele apar în mulțime/vector și astfel este imposibil pentru un Prover să demonstreze două valori diferite la aceiași poziție. 

\pagebreak
\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{hashtree.png}
\caption{Arbore Merkle sparse de adâncime 3 }
\label{fig:arbore_hash1}
\end{figure}

\subsection{Demonstrații de apartenență - $Prove(x,S)$}

O demonstrație de apartenență în contextul arborilor Merkle presupune  parcurgerea corectă a drumului de la nodul frunză cu valorea $POS(x)$ pentru care se face demonstrația până la rădăcina arborelui.

Funcția $Prove(x,S)$ generează vectorii de lungime $\lfloor log(|S|) \rfloor$ : \emph{siblings} - vectorul cu fiecare nod frate din fiecare nivel și \emph{path} - vectorul care codifică poziția nodului curent în funcția hash pentru a calcula nodul următor. În implementare folosim 0 pentru stânga și 1 pentru dreapta. Pe lângă cei doi vectori care atestă că elementul face parte din mulțimea $S$ la poziția indicată , un Prover mai trebuie să demonstreze și faptul că știe preimaginea valorii $POS(x)$ prin funcția hash aleasă , printr-o semnatură a unui mesaj sau un circuit zk-SNARK simplu.

În Figura \ref{fig:demonstrație_arbore_hash} de mai jos sunt colorate cu verde toate nodurile care fac parte din vectorul $siblings_C$ pentru demonstrația de apartenență a elementului $C$.

\pagebreak

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{hashtreeProof.png}
    \caption{Demonstrație pentru nodul cu cheia secretă $C$}
    \label{fig:demonstrație_arbore_hash}
\end{figure}

În acest exemplu , $Prove(x,S)$ generează vectorii $siblings_C= [ D',AB',00FG' ],$
$path_C=[0,1,0]$ împreună cu preimaginea C sau o semnatură/demonsrație zk pentru cheia secretă C.

\subsection{Verificarea demonstrației - $Verify(A,x,\pi_x)$}

Verificarea unei demonstrații Merkle presupune verificarea semnături și recalcularea rădăcinii arborelui folosind vectorii $siblings$ și $path$ și funcția publică hash.

Dacă rădăcinia calculată este egală cu rădăcina arborelui Merkle atunci demonstrația este acceptată altfel este respinsă.

Verifier-ul poate să evalueze o astfel de demonstrație într-un timp logaritmic și fără să salveze în memorie întreg arborele. Deși eficientă, acestă metodă de demonstrare nu păstrează datele private deoarece Verifier-ul află semnatura și poziția hash-ului cheii secrete în arbore.

\section{Demonstrații de non-apartenență}
Potrivit definiției de mai sus un arbore hash Merkle este un acumulator criptografic \emph{dinamic}, care suportă operațiile de inserare,actualizare și ștergere, însă în practică nu dorim să executăm operațiile de actualizare sau ștergere deoarece acestea pot duce la scurgeri de informații cu privire la nodurile care au fost actualizate.

\subsection{Modelul UTXO}
Pentru a elimina un nod dintr-un arbore Merkle acesta trebuie \emph{anulat} folosind un \emph{nullifier}. Un nullifier este un hash-commitment compus din cheia secretă a nodului si ID-ul arborelui Merkle din care face parte , prin care se indică faptul că nodul a fost "consumat".În cazul in care dorim să actualizăm valoarea unui nod , trebuie sa anulăm nodul vechi și sa inserăm un nod cu valoarea nouă. 

Valoarea unui nullifier , de obicei un hash , nu trebuie să dezvăluie ce nod anulează din arborele hash și este de obicei salvată într-un alt arbore Merkle sparse numit \emph{"Nullifier tree"}. Acest model cu doi arbori hash se numește UTXO Model (eng. \emph{Unspent Transactions Outputs}) și este folosit de exemplu în gestionarea tranzacțiilor cu criptomonede. Modelul UTXO este util deoarece rezolvă o problemă de securitate în ceea ce privește demonstrațiile uzuale: replay attacks - folosirea repetată a aceleiași demonstrații.\cite{stanford_blockchain:2022}

Pentru a demonstra apartenența unui element $x$ în modelul UTXO trebuie să demonstrăm că $POS(x)$ face parte din arborele hash și faptul ca nullifier-ul asociat cheii secrete nu se află in nullifier Tree. 

\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/nullify.png}
    \caption{Calculul unui nullifier pentru elementul cu cheia secretă "D"}
    \label{fig:nullify_calc}
\end{figure}

\subsection{Verificarea în modelul UTXO }
În general arborele nullifier este un arbore hash sparse 

aici o sa scriu despre cum verificarea de non apartenenta in arborele de nullifier este constanta insa nu este rapida in contextul zero knowledge



\printbibliography
\end{document}
